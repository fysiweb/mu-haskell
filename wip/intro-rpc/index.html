<!DOCTYPE html>
<html>
    <head>
    <meta charset="UTF-8">

    

    <title>Mu-Haskell: Introduction for RPC</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Mu is a purely functional library for building microservices.">
    <meta name="keywords" content="functional-programming, monads, monad-transformers, functional-data-structure, swift, bow, fp-types, adt, free-monads, tagless-final, mtl, for-comprehension, category-theory">

    <meta property="og:image" content="/mu-haskell/wip/img/poster.png" />
    <meta property="og:title" content="Mu-Haskell: Introduction for RPC" />
    <meta property="og:site_name" content="Mu-Haskell: Introduction for RPC" />
    <meta property="og:url" content="https://higherkindess.io/mu-haskell" />
    <meta property="og:type" content="website" />
    <meta property="og:description" content="Mu is a purely functional library for building microservices." />
    <meta property="og:keywords" content="functional-programming, monads, monad-transformers, functional-data-structure, swift, bow, fp-types, adt, free-monads, tagless-final, mtl, for-comprehension, category-theory" />

    <meta name="twitter:text:description" content="Mu is a purely functional library for building microservices." />
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@47deg">
    <meta name="twitter:creator" content="@47deg">
    <meta name="twitter:image" content="/mu-haskell/wip/img/poster.png" />

    <meta property="github-info" data-github-owner="higherkindness" data-github-repo="mu-haskell" />

    <script defer src="/mu-haskell/wip/js/docs.js"></script>

    <!-- Favicon -->
    <link rel="shortcut icon" href="/mu-haskell/wip/img/favicon.png">

    <!-- mu-haskell docs css -->
    <link rel="stylesheet" type="text/css" href="/mu-haskell/wip/css/docs.css">
</head>

    <body>
        <div id="site-sidebar" class="site-sidebar">
  <div class="sidebar-brand">
    <a href="/mu-haskell/wip/" class="brand" title="Mu-Haskell">
      <img
        src="/mu-haskell/wip/img/nav-brand-white.svg"
        alt="Mu-Haskell"
        class="brand-wrapper"
      />
      <span>Mu-Haskell</span>
    </a>
    <button
      id="main-toggle"
      type="button"
      title="Close"
      class="button sidebar-toggle"
    >
      <span class="close"></span>
    </button>
  </div>
  <div class="sidebar-menu">
    
      

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
      
      <a
        href="/mu-haskell/wip/"
        class=""
        title="Start"
      >
        Start
      </a>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  open">
       
      <button
        type="button"
        title="Open Introduction"
        class="button drop-nested"
      >
        Introduction
      </button>
      <div class="caret"></div>
      

      <div class="sub-menu">
        
        
        
        <a
          class="active"
          href="/mu-haskell/wip/intro-rpc/"
          title="For RPC"
        >
          For RPC
        </a>
        
        
        
        <a
          class=""
          href="/mu-haskell/wip/intro-graphql/"
          title="For GraphQL"
        >
          For GraphQL
        </a>
        
      </div>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
       
      <a
        href="/mu-haskell/wip/schema/"
        title="Schemas"
        class="drop-nested"
      >
        Schemas
      </a>
      <div class="caret"></div>
      

      <div class="sub-menu">
        
        
        
        <a
          class=""
          href="/mu-haskell/wip/serializers/"
          title="Serialization formats"
        >
          Serialization formats
        </a>
        
        
        
        <a
          class=""
          href="/mu-haskell/wip/registry/"
          title="Registry"
        >
          Registry
        </a>
        
        
        
        <a
          class=""
          href="/mu-haskell/wip/optics/"
          title="Mu-Optics"
        >
          Mu-Optics
        </a>
        
      </div>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
       
      <a
        href="/mu-haskell/wip/rpc/"
        title="Services"
        class="drop-nested"
      >
        Services
      </a>
      <div class="caret"></div>
      

      <div class="sub-menu">
        
        
        
        <a
          class=""
          href="/mu-haskell/wip/grpc/server/"
          title="gRPC servers"
        >
          gRPC servers
        </a>
        
        
        
        <a
          class=""
          href="/mu-haskell/wip/grpc/client/"
          title="gRPC clients"
        >
          gRPC clients
        </a>
        
        
        
        <a
          class=""
          href="/mu-haskell/wip/graphql/"
          title="GraphQL"
        >
          GraphQL
        </a>
        
        
        
        <a
          class=""
          href="/mu-haskell/wip/openapi/"
          title="OpenAPI / REST"
        >
          OpenAPI / REST
        </a>
        
      </div>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
       
      <button
        type="button"
        title="Open Integrations"
        class="button drop-nested"
      >
        Integrations
      </button>
      <div class="caret"></div>
      

      <div class="sub-menu">
        
        
        
        <a
          class=""
          href="/mu-haskell/wip/db/"
          title="Databases"
        >
          Databases
        </a>
        
        
        
        <a
          class=""
          href="/mu-haskell/wip/transformer/"
          title="Transformers"
        >
          Transformers
        </a>
        
        
        
        <a
          class=""
          href="/mu-haskell/wip/middleware/"
          title="Middleware"
        >
          Middleware
        </a>
        
      </div>
      
    </div>
    

      
      
      
      

      
      
      

      

      

    <div class="sidebar-menu-item  ">
      
      <a
        href="/mu-haskell/wip/talks/"
        class=""
        title="Talks"
      >
        Talks
      </a>
      
    </div>
    
    
  </div>
</div>

        <main id="site-doc" class="site-doc">
    <div class="doc-header">
      <button
        id="menu-toggle"
        type="button"
        class="button doc-toggle"
        title="Toggle">
          <img src="/mu-haskell/wip/img/sidebar-icon-open.svg" alt="Toggle" title="Toggle">
      </button>

      <div class="link-container">
        
        <div id="version-dropdown" class="link-item">

    <button class="button link-like strong" onclick="openDropdown(event)" title="Version">
      
        <i class="nav-item-icon fa fa-lg " aria-hidden="true"></i>
        <span class="nav-item-text">Version</span>
      
    </button>

    <ul class="dropdown dropdown-content">
      
      <li class="dropdown-item">
        <a class="dropdown-item-link" title="Stable" href="https://higherkindness.io/mu-haskell/" target="_blank" rel="noopener noreferrer">
            <span>
              Stable
            </span>
        </a>
      </li>
      
      <li class="dropdown-item">
        <a class="dropdown-item-link" title="Next" href="https://higherkindness.io/mu-haskell/wip" target="_blank" rel="noopener noreferrer">
            <span>
              Next
            </span>
        </a>
      </li>
      
    </ul>

</div>

        
        <div id="api-docs-dropdown" class="link-item">

    <button class="button link-like strong" onclick="openDropdown(event)" title="API Docs">
      
        <i class="nav-item-icon fa fa-lg " aria-hidden="true"></i>
        <span class="nav-item-text">API Docs</span>
      
    </button>

    <ul class="dropdown dropdown-content">
      
      <li class="dropdown-item">
        <a class="dropdown-item-link" title="Stable" href="https://higherkindness.io/mu-haskell/haddock" target="_blank" rel="noopener noreferrer">
            <span>
              Stable
            </span>
        </a>
      </li>
      
      <li class="dropdown-item">
        <a class="dropdown-item-link" title="Next" href="https://higherkindness.io/mu-haskell/wip/haddock" target="_blank" rel="noopener noreferrer">
            <span>
              Next
            </span>
        </a>
      </li>
      
    </ul>

</div>

        
        <div class="link-item">
          <a href="https://github.com/higherkindness/mu-haskell" title="GitHub repo" target="_blank" rel="noopener noreferrer">
            <span class="strong">GitHub</span>
            <span id="stars-count"></span>
          </a>
        </div>
      </div>

    </div>
    <div class="doc-content">
        <h1 id="introduction-to-mu-haskell-for-rpc">Introduction to Mu-Haskell for RPC</h1>

<p>Many companies have embraced microservices architectures as the best way to scale up their internal software systems, and separate work across different company divisions and development teams. Microservices architectures also allow teams to turn an idea or bug report into a working feature or fix in production more quickly, in accordance to the agile principles.</p>

<p>However, microservices are not without costs. Every connection between microservices becomes now a boundary that requires one service to act as a server, and the other to act as the client. Each service needs to include an implementation of the protocol, the encoding of the data for transmission, etc. The business logic of the application also starts to spread around several code bases, making it difficult to maintain.</p>

<h2 id="what-is-mu-haskell">What is Mu-Haskell?</h2>

<p>The main goal of Mu-Haskell is to allow you to focus on your domain logic, instead of worrying about format and protocol issues. To achieve this goal, Mu-Haskell provides two sets of packages:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">mu-schema</code> and <code class="language-plaintext highlighter-rouge">mu-rpc</code> define schemas for data and services, in a format- and protocol-independent way. These schemas are checked at compile-time, so you also gain an additional layer of type-safety.</li>
  <li><code class="language-plaintext highlighter-rouge">mu-avro</code>, <code class="language-plaintext highlighter-rouge">mu-protobuf</code>, <code class="language-plaintext highlighter-rouge">mu-grpc</code>, <code class="language-plaintext highlighter-rouge">mu-graphql</code> (and other to come) implement each concrete format and protocol, following the interfaces laid out by the former two. In addition, most of those packages can turn a schema in the corresponding format into the corresponding one in <code class="language-plaintext highlighter-rouge">mu-schema</code> and <code class="language-plaintext highlighter-rouge">mu-rpc</code> terms, alleviating the need to duplicate definitions.</li>
</ul>

<h2 id="quickstart">Quickstart</h2>

<h3 id="super-quick-summary">Super-quick summary</h3>

<ol>
  <li>Create a new project with <code class="language-plaintext highlighter-rouge">stack new</code>.</li>
  <li>Define your schema and your services in the <code class="language-plaintext highlighter-rouge">.proto</code> file.</li>
  <li>Map to your Haskell data types in <code class="language-plaintext highlighter-rouge">src/Schema.hs</code>, or use optics.</li>
  <li>Implement the server in <code class="language-plaintext highlighter-rouge">src/Main.hs</code>.</li>
</ol>

<h3 id="step-by-step">Step by step</h3>

<p>As an appetizer we are going to develop the same service as in the <a href="https://grpc.io/docs/quickstart/">gRPC Quickstart Guide</a>. The service is defined as a <code class="language-plaintext highlighter-rouge">.proto</code> file, which includes the schema for the messages and the signature for the methods in the service. The library also supports <code class="language-plaintext highlighter-rouge">.avdl</code> files which declare the messages in Avro IDL, check the <a href="/mu-haskell/wip/serializers/">serialization</a> section for more information.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">service</span> <span class="nc">Service</span> <span class="o">{</span>
  <span class="n">rpc</span> <span class="nf">SayHello</span> <span class="o">(</span><span class="nc">HelloRequest</span><span class="o">)</span> <span class="n">returns</span> <span class="o">(</span><span class="nc">HelloReply</span><span class="o">)</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="n">message</span> <span class="nc">HelloRequest</span> <span class="o">{</span> <span class="n">string</span> <span class="n">name</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="o">}</span>
<span class="n">message</span> <span class="nc">HelloReply</span> <span class="o">{</span> <span class="n">string</span> <span class="n">message</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="o">}</span>
</code></pre></div></div>

<p>To get started with the project, we provide a <a href="https://docs.haskellstack.org">Stack</a> template (in fact, we recommend that you use Stack as your build tool, although Cabal should also work perfectly fine). You should run:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>stack new my_project https://raw.githubusercontent.com/higherkindness/mu-haskell/master/templates/grpc-server-protobuf.hsfiles -p "author-email:your@email.com" -p "author-name:Your name"
</code></pre></div></div>

<p><strong>WARNING:</strong> Do not include a hyphen in your project name, as it will cause the template to generate a ‘.proto’ file containing an invalid package name. Use <code class="language-plaintext highlighter-rouge">my_project</code>, not <code class="language-plaintext highlighter-rouge">my-project</code>.</p>

<p>This command creates a new folder called <code class="language-plaintext highlighter-rouge">my_project</code>, with a few files. The most important from those are the <code class="language-plaintext highlighter-rouge">.proto</code> file, in which you will define your service; <code class="language-plaintext highlighter-rouge">src/Schema.hs</code>, which loads the service definition at compile-time; and <code class="language-plaintext highlighter-rouge">src/Main.hs</code>, which contains the code of the server.</p>

<p>The first step to get your project running is defining the right schema and service. In this case, you can just copy the definition above after the <code class="language-plaintext highlighter-rouge">package</code> declaration.</p>

<h4 id="data-type-definition">Data type definition</h4>

<p>The second step is to define Haskell types corresponding to the message types in the gRPC definition. The recommended route is to create new Haskell data types and check for compatibility at compile-time. The goal is to discourage from making your domain types simple copies of the protocol types. Another possibility is to use the <code class="language-plaintext highlighter-rouge">optics</code> bridge and work with lenses for the fields.</p>

<h5 id="using-haskell-types">Using Haskell types</h5>

<p>The aforementioned <code class="language-plaintext highlighter-rouge">.proto</code> file defines two messages. The corresponding data types are as follows:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">HelloRequestMessage</span>
  <span class="o">=</span> <span class="kt">HelloRequestMessage</span> <span class="p">{</span> <span class="n">name</span> <span class="o">::</span> <span class="kt">T</span><span class="o">.</span><span class="kt">Text</span> <span class="p">}</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span>
           <span class="p">,</span> <span class="kt">ToSchema</span>   <span class="kt">TheSchema</span> <span class="s">"HelloRequest"</span>
           <span class="p">,</span> <span class="kt">FromSchema</span> <span class="kt">TheSchema</span> <span class="s">"HelloRequest"</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">HelloReplyMessage</span>
  <span class="o">=</span> <span class="kt">HelloReplyMessage</span> <span class="p">{</span> <span class="n">message</span> <span class="o">::</span> <span class="kt">T</span><span class="o">.</span><span class="kt">Text</span> <span class="p">}</span>
  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Generic</span>
           <span class="p">,</span> <span class="kt">ToSchema</span>   <span class="kt">TheSchema</span> <span class="s">"HelloReply"</span>
           <span class="p">,</span> <span class="kt">FromSchema</span> <span class="kt">TheSchema</span> <span class="s">"HelloReply"</span><span class="p">)</span>
</code></pre></div></div>

<p>These data types should be added to the file <code class="language-plaintext highlighter-rouge">src/Schema.hs</code>, under the line that starts <code class="language-plaintext highlighter-rouge">grpc ...</code>. (See the <a href="/mu-haskell/wip/rpc/">RPC services page</a> for information about what that line is doing.)</p>

<p>You can give the data types and their constructors any name you like. However, keep in mind that:</p>

<ul>
  <li>The names of the fields must correspond with those in the <code class="language-plaintext highlighter-rouge">.proto</code> files. Otherwise you have to use a <em>custom mapping</em>, which is fully supported by <code class="language-plaintext highlighter-rouge">mu-schema</code> but requires more code.</li>
  <li>The name <code class="language-plaintext highlighter-rouge">TheSchema</code> refers to a type generated by the <code class="language-plaintext highlighter-rouge">grpc</code> function, so it must match the first argument to that function.</li>
  <li>The name between quotes in each <code class="language-plaintext highlighter-rouge">deriving</code> clause defines the message type in the <code class="language-plaintext highlighter-rouge">.proto</code> file each data type corresponds to.</li>
  <li>To use the automatic-mapping functionality, it is required to also derive <code class="language-plaintext highlighter-rouge">Generic</code>, don’t forget it!</li>
</ul>

<h5 id="using-optics">Using optics</h5>

<p>As we mentioned above, you may decide to not introduce new Haskell types, at the expense of losing some automatic checks against the current version of the schema. However, you gain access to a set of lenses and optics which can be used to inspect the values. In the Mu jargon, values from a schema which are not Haskell types are called <em>terms</em>, and we usually define type synonyms for each of them.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">type</span> <span class="kt">HelloRequestMessage'</span> <span class="o">=</span> <span class="kt">Term</span> <span class="kt">TheSchema</span> <span class="p">(</span><span class="kt">TheSchema</span> <span class="o">:/:</span> <span class="s">"HelloRequest"</span><span class="p">)</span>
<span class="kr">type</span> <span class="kt">HelloReplyMessage'</span>   <span class="o">=</span> <span class="kt">Term</span> <span class="kt">TheSchema</span> <span class="p">(</span><span class="kt">TheSchema</span> <span class="o">:/:</span> <span class="s">"HelloReply"</span><span class="p">)</span>
</code></pre></div></div>

<p>The arguments to <code class="language-plaintext highlighter-rouge">Term</code> closely correspond to those in <code class="language-plaintext highlighter-rouge">FromSchema</code> and <code class="language-plaintext highlighter-rouge">ToSchema</code> described above.</p>

<h4 id="server-implementation">Server implementation</h4>

<p>If you try to compile the project right now by means of <code class="language-plaintext highlighter-rouge">stack build</code>, you will receive an error about <code class="language-plaintext highlighter-rouge">server</code> not having the right type. This is because you haven’t yet defined any implementation for your service. This is one of the advantages of making the compiler aware of your service definitions: if the <code class="language-plaintext highlighter-rouge">.proto</code> file changes, you need to adapt your code correspondingly, or otherwise the project doesn’t even compile!</p>

<p>Open the <code class="language-plaintext highlighter-rouge">src/Main.hs</code> file. The contents are quite small right now: a <code class="language-plaintext highlighter-rouge">main</code> function asks to run the gRPC service defined by <code class="language-plaintext highlighter-rouge">server</code>, using Protocol Buffers as serialization layer. The <code class="language-plaintext highlighter-rouge">server</code> function, on the other hand, declares that it implements the <code class="language-plaintext highlighter-rouge">Service</code> service in its signature, but contains no implementations.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">main</span> <span class="o">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="n">main</span> <span class="o">=</span> <span class="n">runGRpcApp</span> <span class="n">msgProtoBuf</span> <span class="mi">8080</span> <span class="n">server</span>

<span class="n">server</span> <span class="o">::</span> <span class="p">(</span><span class="kt">MonadServer</span> <span class="n">m</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">SingleServerT</span> <span class="kt">Service</span> <span class="n">m</span> <span class="kr">_</span>
<span class="n">server</span> <span class="o">=</span> <span class="n">singleService</span> <span class="nb">()</span>
</code></pre></div></div>

<p>The simplest way to provide an implementation for a service is to define one function for each method. You can define those functions completely in terms of Haskell data types; in our case <code class="language-plaintext highlighter-rouge">HelloRequestMessage</code> and <code class="language-plaintext highlighter-rouge">HelloReplyMessage</code>. Here is an example definition:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sayHello</span> <span class="o">::</span> <span class="p">(</span><span class="kt">MonadServer</span> <span class="n">m</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">HelloRequestMessage</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="kt">HelloReplyMessage</span>
<span class="n">sayHello</span> <span class="p">(</span><span class="kt">HelloRequestMessage</span> <span class="n">nm</span><span class="p">)</span>
  <span class="o">=</span> <span class="n">pure</span> <span class="o">$</span> <span class="kt">HelloReplyMessage</span> <span class="p">(</span><span class="s">"hi, "</span> <span class="o">&lt;&gt;</span> <span class="n">nm</span><span class="p">)</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">MonadServer</code> portion in the type is mandated by <code class="language-plaintext highlighter-rouge">mu-rpc</code>; it tells us that in a method we can perform any <code class="language-plaintext highlighter-rouge">IO</code> actions and additionally throw server errors (for conditions such as <em>not found</em>). We do not make use of any of those here, so we simply use <code class="language-plaintext highlighter-rouge">return</code> with a value. We could even make the definition a bit more polymorphic by replacing <code class="language-plaintext highlighter-rouge">MonadServer</code> by <code class="language-plaintext highlighter-rouge">Monad</code>.</p>

<p>Another possibility is to use the <code class="language-plaintext highlighter-rouge">optics</code>-based API in <code class="language-plaintext highlighter-rouge">Mu.Schema.Optics</code>. In that case, you access the value of the fields using <code class="language-plaintext highlighter-rouge">(^.)</code> followed by the name of the field after <code class="language-plaintext highlighter-rouge">#</code>, and build messages by using <code class="language-plaintext highlighter-rouge">record</code> followed by a tuple of the components. The previous example would then be written:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">{-# language OverloadedLabels #-}</span>

<span class="n">sayHello</span> <span class="o">::</span> <span class="p">(</span><span class="kt">MonadServer</span> <span class="n">m</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="kt">HelloRequestMessage'</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="kt">HelloReplyMessage'</span>
<span class="n">sayHello</span> <span class="p">(</span><span class="kt">HelloRequestMessage</span> <span class="n">nm</span><span class="p">)</span>
  <span class="o">=</span> <span class="n">pure</span> <span class="o">$</span> <span class="n">record</span> <span class="p">(</span><span class="s">"hi, "</span> <span class="o">&lt;&gt;</span> <span class="n">nm</span> <span class="o">^.</span> <span class="o">#</span><span class="n">name</span><span class="p">)</span>
</code></pre></div></div>

<p>How does <code class="language-plaintext highlighter-rouge">server</code> know that <code class="language-plaintext highlighter-rouge">sayHello</code> (any of the two versions) is part of the implementation of the service? We have to tell it, by declaring that <code class="language-plaintext highlighter-rouge">sayHello</code> implements the <code class="language-plaintext highlighter-rouge">SayHello</code> method from the gRPC definition. If you had more methods, you list each of them using tuple syntax.</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">server</span> <span class="o">=</span> <span class="n">singleService</span> <span class="p">(</span><span class="n">method</span> <span class="o">@</span><span class="s">"SayHello"</span> <span class="n">sayHello</span><span class="p">)</span>
</code></pre></div></div>

<p>At this point you can build the project using <code class="language-plaintext highlighter-rouge">stack build</code>, and then execute via <code class="language-plaintext highlighter-rouge">stack run</code>. This spawns a gRPC server at port 8080, which you can test using applications such as <a href="https://github.com/uw-labs/bloomrpc">BloomRPC</a>.</p>

    </div>
</main>

    </body>
</html>
